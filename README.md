۱. وارد کردن کتابخانه‌ها
python
Copy
Edit
from flask import Flask, jsonify
Flask: خودِ فریمورک وب؛ مسئول دریافت درخواست (Request) و ارسال پاسخ (Response)

jsonify: کمک می‌کند دیکشنری‌های پایتون را به‌درستی به قالب JSON تبدیل و با هدر Content-Type: application/json ارسال کند

نکته کوچک: اگر بجای jsonify مستقیماً return {"key": "value"} بنویسی، Flask در نسخه‌های جدید آن را به JSON تبدیل می‌کند، اما استفاده از jsonify پی استیبلتی بیشتری دارد.

۲. ساخت اپلیکیشن Flask
python
Copy
Edit
app = Flask(__name__)
__name__ به Flask می‌گوید این ماژول کجاست (برای پیدا کردن فایل‌های استاتیک، تمپلیت‌ها و …)

اگر به جای __name__ رشته‌ای دلخواه بگذارید، Flask ممکن است نتواند مسیر صحیح فایل‌ها را بیابد.

۳. تعریف روت اصلی (Home)
python
Copy
Edit
@app.route('/', methods=['GET'])
def home():
    return jsonify({"message": "Welcome to the Task API! Use /tasks to see all tasks."}), 200
@app.route('/')

/ یعنی ریشه‌ی URL (Host و Port + /)

methods=['GET']

فقط درخواست‌های خواندن پذیرفته می‌شوند

def home():

نام دلخواه تابع است؛ می‌تواند هر چیزی باشد

return jsonify(...), 200

دیکشنری داخل jsonify به کلاینت برمی‌گردد

عدد 200 وضعیت موفق (OK) است

مثال:
اگر مرورگر باز کنی http://127.0.0.1:8000/، JSON زیر را می‌بینی:

json
Copy
Edit
{
  "message": "Welcome to the Task API! Use /tasks to see all tasks."
}
۴. تعریف روت لیست تسک‌ها
python
Copy
Edit
@app.route('/tasks', methods=['GET'])
def get_all_tasks():
    # فرض کن اینجا کد اصلی تو برای لیست تسک‌هاست
    return jsonify([])
مسیر /tasks

متد GET

برمی‌گرداند یک آرایه خالی ([])

نکته ریز: برای آینده باید اینجا از پایگاه داده بخوانی، تبدیل به لیست دیکشنری کنی و jsonify کنی.

۵. بلوک اجرای اصلی
python
Copy
Edit
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8000, debug=True)
شرط __name__ == '__main__'

تضمین می‌کند این بخش وقتی اجرا شود که فایل را با python app.py اجرا کنی

اگر فایل را از جای دیگر import کنی، این بلوک اجرا نمی‌شود

app.run(...)

host='0.0.0.0'

روی تمام رابط‌های شبکه گوش می‌دهد (نه فقط 127.0.0.1)

باعث می‌شود از کامپیوتر دیگر توی شبکه هم دسترسی داشته باشی

port=8000

شماره پورت برنامه؛ می‌توانی هر عدد بین ۱۰۲۴ تا ۶۵۵۳۵ را انتخاب کنی

debug=True

در صورت ارور، صفحه‌ی خطا با جزئیات را در مرورگر نشان می‌دهد

به‌محض ذخیره‌ی فایل، سرور اتوماتیک ری‌لود می‌شود

مثال: پس از اجرای python app.py
در کنسول می‌بینی:

pgsql
Copy
Edit
* Serving Flask app "app"
* Debug mode: on
* Running on http://0.0.0.0:8000/ (Press CTRL+C to quit)
۶. ریزنکات و توصیه‌ها
مغزِ برنامه: هرچه بعد از if __name__ == '__main__': بنویسی، فقط در اجرای مستقیم اعمال می‌شود.

مسیر /tasks: الان صرفاً مثال زده شده؛ در نسخه‌ی کامل باید امکان POST, PUT, DELETE و کار با دیتابیس را اضافه کنی.

عدد پورت:

اگر ۸۰۰۰ روی سیستمت آزاد نیست، خطای OSError: Address already in use می‌آید

می‌توانی به ۵۰۰۰ یا ۸۰۸۰ تغییرش دهی

حالت Debug:

در تولید (Production) حتماً debug=False یا از سرور WSGI مثل Gunicorn استفاده کن.

برگشت JSON:

کلاینت‌های موبایل و وب API فقط JSON می‌خواهند؛ استفاده از jsonify الزامی است.


نکات مهم
مسیر مشترک
همه سه عملیات روی /tasks/bulk هستند ولی با متدهای مختلف (POST, PUT, DELETE).

اعتبارسنجی ورودی

برای درج: چک می‌کنیم لیست باشد و هر آیتم title داشته باشد.

برای ویرایش: فقط idهای معتبر را می‌پذیریم و اگر فیلدی برای آپدیت موجود باشد، وارد عملیات می‌کنیم.

برای حذف: آرایه‌‌ای از ids دریافت می‌کنیم و فقط آن‌هایی که ObjectId.is_valid هستند را در کوئری حذف می‌کنیم.

عملیات گروهی

insert_many برای درج انبوه

bulk_write + UpdateOne برای ویرایش چندگانه بدون round-tripهای متعدد

delete_many برای حذف چندگانه

Response
هر endpoint تعداد آیتم‌های درج‌شده، ویرایش‌شده یا حذف‌شده را در JSON می‌فرستد.

با این سه endpoint، حالا می‌توانی در یک درخواست همزمان:

چندین تسک را درج کنی

چندین تسک را ویرایش کنی

چندین تسک را حذف کنی

کافی است در Postman یا هر کلاینت HTTP دیگری، متد را انتخاب و JSON مناسب را به /tasks/bulk بفرستی.




| بخش                                     | توضیح                                                                                    |
| :-------------------------------------- | :--------------------------------------------------------------------------------------- |
| `from flask import ...`                 | تمام ماژول‌های لازم برای API را ایمپورت می‌کند.                                          |
| `PyMongo`                               | برای اتصال برنامه‌ی Flask به دیتابیس MongoDB.                                            |
| `@app.route('/', methods=['GET'])`      | صفحه‌ی خوش‌آمدگویی به کاربر.                                                             |
| `@app.route('/tasks', methods=['GET'])` | همه‌ی تسک‌های موجود را لیست می‌کند.                                                      |
| `/tasks/bulk [POST]`                    | همزمان چند تسک جدید درج می‌کند.                                                          |
| `/tasks/bulk [PUT]`                     | همزمان چند تسک را آپدیت می‌کند.                                                          |
| `/tasks/bulk [DELETE]`                  | همزمان چند تسک را حذف می‌کند.                                                            |
| `/tasks/search [GET]`                   | جستجو در تسک‌ها براساس عنوان، توضیح، یا تاریخ ساخته شدن.                                 |
| `check_reminders()`                     | پس زمینه اجرا می‌شود، اگر زمان یک Reminder رسیده باشد، پیام چاپ می‌کند.                  |
| `/tasks/count [GET]`                    | تعداد کل تسک‌ها، تعداد تکمیل‌شده‌ها و تکمیل‌نشده‌ها را برمی‌گرداند.                      |
| `threading.Thread(...)`                 | تابع Reminder را بدون قطع شدن برنامه اصلی در پس‌زمینه اجرا می‌کند.                       |
| `if __name__ == '__main__':`            | مشخص می‌کند که این فایل باید مستقیم اجرا شود و Flask را روی پورت 5000 راه‌اندازی می‌کند. |



کلیدی در این کد

حذف کامل دیتابیس با /database/drop.

درج، به‌روزرسانی و حذف همزمان (bulk) تسک‌ها با یک endpoint مشترک اما متدهای متفاوت.

جستجوی ترکیبی بر اساس چند ID، عنوان، توضیحات و تاریخ ایجاد.

فیلتر، مرتب‌سازی، صفحه‌بندی و شماره‌گذاری ردیف‌ها در لیست تسک‌ها.

تابع پس‌زمینه reminder_loop برای اعلان تسک‌ها بر اساس reminder_time.

شمارش کل، تکمیل‌شده و باقی‌مانده تسک‌ها با /tasks/counts.

تمامی قسمت‌ها به‌صورت کامنت فارسی توضیح داده شده‌اند
